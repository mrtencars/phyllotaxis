<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="utf-8">
    <title>Subspaces</title>
    <script type="text/javascript" src="./js/Cindy.js"></script>
    <link rel="stylesheet" href="./css/style.css">
</head>
<body>

<script id='csinit' type='text/x-cindyscript'>
    /*** SYSOUTPUT ***/
    strOut = "";

    /*** constants ***/
    defaultColor = [0,0,1];
    defaultPointSize = 3;

    /*** variables ***/
    boolMouseDown = false;
    pointMouse = (0,0);
    cylinder = [];
    baseVector = [0,0];
    mouseInArea = false;
    baseIndex = 0;

    /*** OBJECTS ***/
    // complex number with color and <text>a</text>
    newCTPoint(Index, Cnumber, Color, Text):=({"idx": Index, "z": Cnumber, "c": Color, "t": Text});

    // Cylindrical lattice with divergence angle and height h
    newCLattice(theta,h):=({"angle": theta, "height": h});

    // annotations
    newAnnotation(pointPosition,strText):=(
        {"pos": pointPosition, "text": strText}
    );

    /** METHODS ***/

    // obsolete: project a ctpoint to a equivalent ctpoint near origin
    projectToOrigin(ctpoint,vector):=(
        z1 = ctpoint.z;
        zv = complex(vector);

        // bring the ctpoint close to the x-axis
        while(im(z1-zv)>0,z1=z1-zv);

        // output: projection to cylinder
        (re(z1)-floor(re(z1)+0.5)) + i*im(z1)
    );

    // select the closest ctpoint to a given point
    closestCTPoint(arrCTPoints,Point):=(
        sortarr = sort(arrCTPoints,ctpoint,|ctpoint.z - complex(Point)|);
        sortarr_1;
    );


    // project a ctpoint in the plane to the cylinder
    PlaneToCylinder(CTPoint):=(
        apply(CTPoint,val,key,
            if(key == "z",
                val = complex([-0.5+arctan2(val)/(2*pi),|val|]),
                val = val
            );
        );
    );

    CylinderToPlane(CTPoint,Scaling):=(
        apply(CTPoint,val,key,
            if(key=="z",
                p = gauss(val);
                val = (p.y)^Scaling*exp(i*p.x*360°),
                val = val
            );
        );
    );

    // color a CTPoint
    changeColor(CTPoint,Color):=(
        apply(CTPoint,val,key,
                    if(key == "c",
                        val = Color,
                        val = val
                    );
        );
    );

    // color lattice
    colorLattice(arrCTPoints):= apply(arrCTPoints,ctpoint,
        apply(ctpoint,val,key,
            if(key=="c",
                //val = hue(re(projectToOrigin(ctpoint,baseVector))+0.5),
                val = hue(mod(ctpoint.idx,baseIndex)/baseIndex),
                val = val
            )
        )
    );

    // draw subspaces
    drawLatticeCylinder(arrCTPoints):=(
        arrLength = length(arrCTPoints);
        forall(1..baseIndex,
            k = 1;
            z1 = (arrCTPoints_#).z;
            while(# + k*baseIndex <= arrLength,
                z2 = (arrCTPoints_(# + k*baseIndex).z);
                clr = hue(#/baseIndex);
                if(isInCylinder(z1+complex(baseVector)),
                    draw(gauss(4*z1),gauss(4*z2),color->clr),
                    if(baseVector.x<0,
                        pL = [-0.5,im(z1)+baseVector.y*(-0.5-re(z1))/baseVector.x];
                        pR = [0.5,im(z1)+baseVector.y*(-0.5-re(z1))/baseVector.x];
                        draw(gauss(4*z1),4*pL,color->clr);
                        draw(4*pR,gauss(4*z2),color->clr),
                        pL = [-0.5,im(z1)+baseVector.y*(0.5-re(z1))/baseVector.x];
                        pR = [0.5,im(z1)+baseVector.y*(0.5-re(z1))/baseVector.x];
                        draw(gauss(4*z1),4*pR,color->clr);
                        draw(4*pL,gauss(4*z2),color->clr)
                    )
                );
                k = k+1;
                z1 = z2
            );
        );
    );

    // color a CTPoint in a lattice
    colorCTPoint(lattice,Point,eps,Color):=(
        apply(lattice,ctpoint,
            if(|gauss(ctpoint.z)-Point|<eps,
                changeColor(ctpoint,Color),
                ctpoint
            );
        );
    );

    // creates a scaled spiral with a given radius
    createSpiralR(CLattice,scaling,R):=(
        r = CLattice.height;
        phi = CLattice.angle*360°;
        z = r*exp(i*phi);
        l = 1;
        spiral = [newCTPoint(0,complex([0,0]),defaultColor,text(0))];
        while(|z|<R,
            spiral = append(spiral,newCTPoint(l,z,defaultColor,text(l)));
            l = l+1;
            z = l^scaling*r*exp(i*l*phi);
        );
        spiral
    );

    // creates points of a cylindrical lattice with a given max height
    createCLatticePointsH(CLattice,maxheight,scaling):=(
        lattice = [newCTPoint(0,complex([0,0]),defaultColor,text(0))];
        h = CLattice.height;
        phi = CLattice.angle;
        z = complex([phi-floor(0.5+phi),h*scaling]);
        l = 1;
        while(im(z)<maxheight,
            lattice = append(lattice,newCTPoint(l,z,defaultColor,text(l)));
            l = l+1;
            z = complex([l*phi-floor(0.5+l*phi),l*h*scaling]);
        );
        lattice
    );

    // draw a list of CTPoints
    drawLattice(lattice,textsize,offset,psize):=(
        forall(lattice,point,
            draw(gauss(point.z),color->point.c,size->psize);
            drawtext(gauss(point.z)+[offset,offset],point.t,size->textsize)
        );
        boolMouseDown = false;
    );

    /**** GRAPHICS ****/
    // draw cylinder
    drawCylinder(varHeight,intLineSize):=(
        linesize(intLineSize);
        linecolor([0,0,0]);
        draw([(0.5,varHeight),(0.5,0)]);
        draw([(-0.5,varHeight),(-0.5,0)]);
        draw(join([0,0],[1,0]));
        greset();
    );

    // draw arrow
    drawArrow(a,b,col,alp):=(
        draw(a,4*b,
            color->col,
            size->2,
            alpha->alp,
            arrow->true,
            arrowshape->"full",
            arrowsides->"==>",
            arrowsize->1.5,
            arrowposition->1
        );
    );

    // check if a given point is in a certain area
    isInArea(area,point):=(
        area_1 <= point.x & point.x <= area_3 & area_4 <= point.y & point.y <= area_2
    );

    // check if a complex number is in a the cylinder
    isInCylinder(z):=if(re(z)<=0.5 & re(z)>-0.5,true,false);

    // draw axis
    drawAxis(strOriantation,arrAnnotations,dblLinesize,dblTextsize,epsilon,offset,arrColor):=(
        linesize(dblLinesize);
        forall(arrAnnotations,annotation,
            P = annotation.pos; // point
            if(strOriantation=="horizontal",
                draw((P.x,epsilon),(P.x,-epsilon),color->arrColor);
                drawtext((P.x-offset,P.y-offset),annotation.text,size->dblTextsize);
            );
            if(strOriantation=="vertical",
                draw((-epsilon,P.y),(epsilon,P.y),color->arrColor);
                drawtext((P.x-offset,P.y-offset),annotation.text,size->dblTextsize);
            );
        );
        greset();
    );

    /**** CANVAS ****/
    createimage("Plane",500,500);
    createimage("Cylinder",100,500);
    createimage("SysOutput",700,100);
</script>

<script id='csdraw' type='text/x-cindyscript'>
    strOut = text(mouseInArea) + " " ;
    scale = 0.5+0.5*|D-B|/|C-B|;
    lattice = newCLattice(A.x/4,A.y/4);
    cylinder = createCLatticePointsH(lattice,5,1);
    if(baseVector != [0,0],
        drawLatticeCylinder(cylinder);
        cylinder = colorLattice(cylinder);
        drawLatticeCylinder(cylinder);
        drawArrow([0,0],baseVector,(0,0,0),0.5)
    );

    //cylinder = colorCTPoint(cylinder,pointMouse,0.02,(1,1,0));
    //spiral = createSpiralR(lattice,scale,5);
    spiral = apply(cylinder,ctpoint,CylinderToPlane(ctpoint,scale));

    xAxis = [
        newAnnotation([-2,0],"-180°"),
        newAnnotation([0,0],"O"),
        newAnnotation([2,0],"180°"),
        newAnnotation([4,0],"360°")
    ];
    drawAxis("horizontal",xAxis,2,14,0.05,0.3,(0,0,0));

    drawtext(A.xy+[0.1,0.1],text(360°*A.x/4));

    clearimage("Plane");
    canvas([-5,-5],[5,-5],"Plane",
        drawLattice(spiral,9,0.0570,5);
    );
    drawimage([2.5,0],[12.5,0],"Plane");

    clearimage("Cylinder");
    canvas([-0.5,0],[0.5,0],"Cylinder",
        h = 5; // height of the cylinder
        drawLattice(cylinder,h,0.05,1.1);
        drawCylinder(h,2);
    );
    drawimage([-2,0],[2,0],"Cylinder");

    clearimage("SysOutput");
    canvas([0,0],[5,0],"SysOutput",
        strOut = strOut + " Mouse: " + text(baseVector);
        drawtext([0,0],strOut,size->8);
    );
    drawimage([-1,-1],[13,-1],"SysOutput");

</script>

<script id='csmousedown' type='text/x-cindyscript'>
    pointMouse = mouse()/4;
    mouseInArea = isInArea([-0.5,3,0.5,0],pointMouse);
    if(mouseInArea,
        boolMouseDown = true;
        baseVector = gauss((closestCTPoint(cylinder,pointMouse)).z);
        baseIndex = closestCTPoint(cylinder,pointMouse).idx;
    );

</script>
<div  id="CSCanvas"></div>
<script type="text/javascript">
    const gslp=[
        {name:"A", type:"Free", pinned:false, size:5, pos:[0.5,0.5]},
        {name:"B", type:"Free", visible: false, pinned:false, size:3, pos:[4,-.5]},
        {name:"C", type:"Free", visible: false, pinned:false, size:3, pos:[12,-.5]},
        {name:"a", type:"Segment", args: [ "C", "B" ],color: [0,0,0], labeled: false},
        {name:"D", type:"PointOnSegment", pinned:false, size:3, args: ["a"], pos:[11,-1]},
        {name:"Text0", type: "Text", color: [0,0,0], size:18, text: "Vergrößerung", pos:[7,-1]},
        {name:"Text1", type: "Text", color: [0,0,0], size:18, text: "Winkel", pos:[11.5,0.1]},
        {name:"Text2", type: "Text", color: [0,0,0], size:18, text: "Radius", pos:[0.1,9.7]}
    ];

    const cdy = CindyJS({
        ports: [{
            id: "CSCanvas",
            width: 800,
            axes: true,
            height: 600,
            transform: [{
                visibleRect: [-2.5,10,12.5,-1]
            }],
            background: "rgb(255,255,255)"
        }],
        scripts: "cs*",
        language: "de",
        autoplay: false,
        defaultAppearance: {
            dimDependent: 0.7,
            fontFamily: "sans-serif",
            lineSize: 1,
            pointSize: 5.0,
            textsize: 12.0
        },
        geometry: gslp,
        use:["katex"]
    });
</script>
</body>
</html>